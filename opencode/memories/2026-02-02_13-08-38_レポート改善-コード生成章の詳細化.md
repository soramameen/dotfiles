---
title: "コンパイラ実験レポート改善 - コード生成章の詳細化"
date: "$(date '+%Y-%m-%d %H:%M:%S')"
topics:
  - compiler
  - report
  - codegen
  - documentation
summary: "最終レポートのコード生成章（第4章）を詳細化するための構成案と説明漏れチェックリスト"
---

# コンテキスト

## 背景
- コンパイラ実験の最終レポート（main.tex）を改善中
- コード生成の章（第4章）を、大きなカテゴリ説明から個別の実装説明へ詳細化
- 方針：共通部分は一度だけ説明し、各演算・構文の固有ポイントに絞る

## 現在のレポート構造
- 4.1 算術式のコード生成（加減乗除を一括説明）
- 4.2 制御構文の翻訳
- 4.3 変数と配列のメモリ管理

## 説明漏れチェックリスト（重要）

### 高優先度（明確な説明漏れ）
- **比較演算6項目**：LT, GT, EQ, LE, GE, NE
  - 現状：制御構文の説明で条件式として軽く触れられているのみ
  - 実装トリック（slt, xori, sub+sltiuなど）が説明されていない

- **NUMBER_AST（数値リテラル）**：完全に説明なし
  - `li`命令で即値をロードする基本処理

### 中優先度（既存セクションの拡張）
- 変数・代入：VAR_AST, ASSIGNMENT_STMT_ASTの詳細
- 配列宣言：ARRAY_DECL_STATEMENT_ASTの処理
- 1次元配列：現在2次元配列の説明が主

---

# 基盤部分の分析結果

## push/pop関数の使用状況
- **定義位置**: codegen.c L5-12
- **使用箇所**: 26箇所
  - 算術演算: 8回（PLUS, MINUS, MUL, DIV各2回）
  - 比較演算: 12回（LT, GT, EQ, LE, GE, NE各2回）
  - 配列アクセス: 6回（ARRAY_ACCESS）

## スタックマシン方式の設計方針
```
二項演算の共通パターン:
1. 右辺を評価 → walk_ast(n->child->brother, fp)
2. 結果を退避 → push("$v0", fp)
3. 左辺を評価 → walk_ast(n->child, fp)
4. 右辺を復帰 → pop("$v1", fp)
5. 演算命令を発行 → fprintf(fp, "op $v0, $v0, $v1\n")
```

## レジスタ割り当てポリシー
- `$v0`: 演算結果および左辺値を格納
- `$v1`: 右辺値（スタックから復帰）
- `$fp`: フレームポインタ（変数アクセスの基準）
- `$sp`: スタックポインタ（一時保存用）

---

# 新しい構成案

## 4.0 コード生成の基盤仕組み（新規セクション）
**全体に共通するロジックを切り出して説明**

### 4.0.1 スタックマシン方式の採用
- レジスタ割り当ての複雑さを回避するための設計選択
- 演算の途中経過をスタックに退避する方式
- メリット：実装の確実性、デバッグの容易さ
- デメリット：メモリアクセス頻度の増加（考察で触れる）

### 4.0.2 スタック操作関数（push/pop）
```c
static void push(const char* reg, FILE*fp) {
    fprintf(fp,"  sw %s, -4($sp)\n",reg);
    fprintf(fp,"  addi $sp, $sp, -4\n");
}

static void pop(const char* reg, FILE *fp) {
    fprintf(fp,"  lw %s, 0($sp)\n", reg);
    fprintf(fp,"  addi $sp, $sp, 4\n");
}
```
- **使用箇所**: 26箇所（算術演算8回、比較演算12回、配列6回）
- **役割**: 二項演算において右辺の値を一時的に退避・復帰

### 4.0.3 レジスタ割り当てポリシー
- `$v0`: 演算結果および左辺値を格納
- `$v1`: 右辺値（スタックから復帰）
- `$fp`: フレームポインタ（変数アクセスの基準）
- `$sp`: スタックポインタ（一時保存用）

### 4.0.4 二項演算の共通パターン
すべての二項演算（算術・比較）で以下の順序を守る：
1. 右辺を評価 → walk_ast(n->child->brother, fp)
2. 結果を退避 → push("$v0", fp)
3. 左辺を評価 → walk_ast(n->child, fp)
4. 右辺を復帰 → pop("$v1", fp)
5. 演算命令を発行 → fprintf(fp, "op $v0, $v0, $v1\n")

---

## 各セクションの構成

### 4.1 算術演算のコード生成
- 4.1.1 加算（add）の実装
- 4.1.2 減算（sub）の実装
- 4.1.3 乗算（mul）の実装（HI/LOレジスタ）
- 4.1.4 除算（div）の実装（HI/LOレジスタ）

### 4.2 比較演算のコード生成（新規セクション）
- 4.2.0 真理値の表現
- 4.2.1 小なり（lt）の実装
- 4.2.2 大なり（gt）の実装（オペランド入れ替え）
- 4.2.3 等価（eq）の実装（sub+sltiu）
- 4.2.4 以下（le）の実装（slt+xori）
- 4.2.5 以上（ge）の実装（slt+xori）
- 4.2.6 不等価（ne）の実装（sub+sltu）

### 4.3 制御構文の翻訳
- 4.3.1 条件判定の仕組み
- 4.3.2 while文の実装
- 4.3.3 if-else文の実装

### 4.4 変数と代入のコード生成
- 4.4.1 数値リテラル（NUMBER_AST）の実装
- 4.4.2 変数参照（VAR_AST）の実装
- 4.4.3 代入文（ASSIGNMENT_STMT_AST）の実装
- 4.4.4 変数宣言（DECL_STATEMENT_AST）の処理

### 4.5 配列のコード生成
- 4.5.1 配列宣言（ARRAY_DECL_STATEMENT_AST）の処理
- 4.5.2 1次元配列の参照・代入
- 4.5.3 2次元配列の参照・代入

---

# 今後の作業

## ステップ
1. まず4.0「コード生成の基盤仕組み」から作成
2. その後、4.1〜4.5を順次詳細化
3. 各セクションで「4.0で説明済み」を引用しつつ、固有ポイントに絞る

## 文体要件
- **学生らしい（だ・である調）**
- **学習プロセスを重視**: どのように考えてこの方針にしたか、という流れで説明
- **苦労・失敗・改善**: 実装過程での試行錯誤にも触れる

## 関連ファイル
- final_report/main.tex（レポート本体）
- final_report/docs/改善.md（本改善計画）
- c-compiler/src/codegen.c（実装コード）
- c-compiler/src/ast.h（ASTノード定義）
