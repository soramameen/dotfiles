---
title: レポート改善-4.1完了状態
date: 2026-02-02
topics:
  - レポート改善
  - 第4章詳細化
  - 算術演算
  - 比較演算
summary: Pレポート第4章「コード生成の実装」の詳細化作業。4.0「コード生成の基盤仕組み」と4.1「算術演算のコード生成」を完了し、4.2「比較演算のコード生成」の構成案を作成した状態。
---

# 現在の状態

## 完了した作業

### 4.0 コード生成の基盤仕組み（既に追加済み）
- 4.0.1 スタックマシン方式の採用
- 4.0.2 スタック操作関数（push/pop）
- 4.0.3 レジスタ割り当てポリシー
- 4.0.4 二項演算の共通パターン（右辺先評価の理由説明済み）

### 4.1 算術演算のコード生成（完了）
- 4.1.0 算術演算の共通パターン（PLUS_AST全体像を例示）
- 加算（add）: 基本的な3オペランド命令
- 減算（sub）: 非可換演算で直感的なオペランド順序になる点を強調
- 乗算（mul）: HI/LOレジスタの仕様 + MAPSの制約（mul擬似命令非対応）
- 除算（div）: 商/剰余の格納先 + 将来的な剰余演算子への言及

**変更点**: 元の4.1節にあった制御構文の内容（while/if文のラベル生成）は削除し、新しい内容に置き換えた。

## 次のステップ

### 4.2 比較演算のコード生成（構成案作成済み、実装待ち）

#### 構成案
- 4.2.0 真理値の表現
  - 真なら1、偽なら0を$v0に格納
  - 制御構文では$v0 == 0で判定
  
- 4.2.1 小なり（lt）: slt命令の基本形
- 4.2.2 大なり（gt）: sltのオペランド逆転トリック
- 4.2.3 等価（eq）: sub + sltiuの組み合わせ
- 4.2.4 以下（le）: slt + xori（論理否定）
- 4.2.5 以上（ge）: slt + xori（論理否定）
- 4.2.6 不等価（ne）: sub + sltu（符号なし比較）

#### 実装コード（codegen.c 159-222行目）
```c
/* a < b true->1, false->0 */
case LT_AST:
    walk_ast(n->child->brother, fp);
    push("$v0",fp);
    walk_ast(n->child, fp);
    pop("$v1",fp);
    fprintf(fp,"   slt $v0, $v0, $v1\n");
    break;

/* a > b true->1, false->0 */
case GT_AST:
    walk_ast(n->child->brother, fp);
    push("$v0",fp);
    walk_ast(n->child, fp);
    pop("$v1",fp);
    fprintf(fp,"   slt $v0, $v1, $v0\n");
    break;

/* a == b true->1, false->0 */
case EQ_AST:
    walk_ast(n->child->brother, fp);
    push("$v0",fp);
    walk_ast(n->child, fp);
    pop("$v1",fp);
    fprintf(fp,"   sub $v0, $v0, $v1\n");
    nop(fp);
    fprintf(fp,"   sltiu $v0, $v0, 1\n");
    break;

/* a <= b true->1, false->0 */
case LE_AST:
    walk_ast(n->child->brother, fp);
    push("$v0",fp);
    walk_ast(n->child, fp);
    pop("$v1",fp);
    // v0 = a, v1 = b
    // check if a <= b, which is same as !(a > b), which is same as !(b < a)
    fprintf(fp,"   slt $t0, $v1, $v0\n");
    nop(fp);
    fprintf(fp,"   xori $v0, $t0, 1\n");
    break;

/* a >= b true->1, false->0 */
case GE_AST:
    walk_ast(n->child->brother, fp);
    push("$v0",fp);
    walk_ast(n->child, fp);
    pop("$v1",fp);
    // v0 = a, v1 = b
    // check if a >= b, which is same as !(a < b)
    fprintf(fp,"   slt $t0, $v0, $v1\n");
    nop(fp);
    fprintf(fp,"   xori $v0, $t0, 1\n");
    break;

/* a != b true->1, false->0 */
case NE_AST:
    walk_ast(n->child->brother, fp);
    push("$v0",fp);
    walk_ast(n->child, fp);
    pop("$v1",fp);
    fprintf(fp,"   sub $v0, $v0, $v1\n");
    nop(fp);
    fprintf(fp,"   sltu $v0, $zero, $v0\n");
    break;
```

#### 未解決の検討事項
1. **nop命令の説明**: EQ, LE, GE, NEでnop命令が挿入されているが、説明が必要か
2. **一時レジスタ$t0の使用**: LE, GEで$t0を使用しているが、レジスタ割り当てについての言及は不要か（4.0.3で触れ済み）
3. **sltiuとsltuの違い**: 即値比較とレジスタ比較の違いを明確に説明すべきか
4. **分量**: 6つの演算子すべてを説明すると長くなりすぎないか

## 関連ファイル

- `/Users/nakajimasoraera/dev/github.com/soramameen/compiler/final_report/main.tex` - レポート本体
- `/Users/nakajimasoraera/dev/github.com/soramameen/compiler/c-compiler/src/codegen.c` - コード生成実装
- `/Users/nakajimasoraera/dev/github.com/soramameen/compiler/final_report/docs/改善.md` - 改善計画書

## 文体要件

- 学生らしい（だ・である調）
- 学習プロセスを重視（なぜその実装を選んだか、試行錯誤の経緯）
- 「4.0.4で説明した共通パターンに従い」などの引用を入れる
- 共通パターンの詳細は省略し、各演算固有のポイントに絞る

## 技術的詳細

### MAPSシミュレータの制約
- mul擬似命令はサポートされていない → mult + mflo で実装
- 完全なMIPSではなくサブセット

### 乗除算のHI/LOレジスタ
- mult命令: 64ビット積をHI（上位32ビット）:LO（下位32ビット）に格納
- div命令: 商をLO、剰余をHIに格納
- 本コンパイラでは32ビット整数のみ扱い、オーバーフローは考慮しない

### 右辺先評価の設計判断
- 4.0.4で十分に説明済み（減算の非可換性によるオペランド順序の問題）
- 4.1.2では重複を避け「非可換演算で直感的なオペランド順序になる利点」に焦点を当てた
